import groovy.util.slurpersupport.GPathResult

//统一工程名，不使用根目录名。
gradle.ext.rootProjectname = "component_app"

gradle.ext.aar_title = "com.gh.android"

def configFile1 = new File(rootDir.absolutePath.replace("$rootProject.name","component_config/lib_config/components_configs.xml"))
println(configFile1.getAbsolutePath())
println(configFile1.getCanonicalPath())

//初始化各个组件配置信息
def configFile = new File("/Users/gh/Desktop/android/android_projects/Component/component_config/lib_config/components_configs.xml")
//def configFile = new File("../../component_config/lib_config/components_configs.xml")
def componentConfigXml = null
try {
    componentConfigXml = new XmlSlurper().parse(configFile)
} catch (Exception e) {
    println(e)
}

//初始化各个组件版本信息
def versionFile = new File("/Users/gh/Desktop/android/android_projects/Component/component_config/lib_config/components_version.xml")
//def versionFile = new File("../../component_config/lib_config/components_version.xml")
def allComponentConfigXml = null
try {
    allComponentConfigXml = new XmlSlurper().parse(versionFile)
} catch (Exception e) {
    println(e)
}

//校验版本信息中的组件数量,计数算出来的版本信息与配置的版本信息作对比
def componentSize = allComponentConfigXml.component.size() + allComponentConfigXml.depthFirst().findAll { it.name() == "dependency" }.size()
if (allComponentConfigXml.@componentCount != componentSize.toString()) {
    throw new Exception("components_version.xml中componentCount=${allComponentConfigXml.@componentCount}与component个数${componentSize}不一致，核对组件配置是否缺失")
}

/**
 * assembleType 构建方式
 * 0：有配置文件构建apk，按照components_configs.xml配置文件
 * 1：无配置文件构建apk，全部使用源码
 * 2：构建aar，全部使用源码（如果使用aar，需要考虑依赖打包顺序的问题）
 */
def assembleType = 0
if (isPublishAar()) {
    assembleType = 2
} else if (!configFile.exists()) {
    assembleType = 1
}

//将组件版本和组件配置信息存为gradle全局变量
//构建方式
gradle.ext.assembleType = assembleType
//数组
gradle.ext.allComponents = allComponentConfigXml.component
//是否编译混淆
gradle.ext.enable_proguard = componentConfigXml?.buildOptions?.enable_proguard != "false"
//是否引入配置文件
gradle.ext.import_config = componentConfigXml?.buildOptions?.import_config != "false"

//以version配置文件为主,下面两个方法为把version完善
//components_version.xml中使用父组件的aarVersion填充子组件的aarVersion，方便后续数据的使用。
allComponentConfigXml.depthFirst().each { GPathResult component ->
    if (component.name() == "dependency") {
        component.@aarVersion = component.parent().@aarVersion.text()
    }
}

//有配置文件构建apk时，将components_configs.xml组件配置信息合并到components_version.xml中，方便后续数据的使用。
//处理子组件的配置联动，使用其父组件的配置
if (gradle.assembleType == 0) {
    //是否开启了全部使用源码快捷配置
    gradle.ext.all_use_sourcecode = componentConfigXml?.buildOptions?.all_sourcecode == "true"
    allComponentConfigXml.depthFirst().each { GPathResult component ->
        if (component.name() == "component") {
            def foundComponent = componentConfigXml?.project?.component?.find { it.@project == component.@project }
            component.@include = foundComponent?.@include?.text() ?: "true"
            if (gradle.all_use_sourcecode) {
                component.@aar = "false"
            } else {
                component.@aar = foundComponent?.@aar?.text() ?: "true"
            }
        } else if (component.name() == "dependency") {
            component.@include = component.parent().@include.text()
            if (gradle.all_use_sourcecode) {
                component.@aar = "false"
            } else {
                component.@aar = component.parent().@aar.text()
            }
        }
    }
}

//日志输出
println("--base-setting.gradle------------------------------------------")

if (gradle.rootProjectname == rootProject.name) {
    println("--主项目构建使用源码的lib库及module_库--")
} else {
    println("--非主项目只构建使用源码的lib_库--")
}

println("--构建开始------------------------------------------")

switch (gradle.assembleType) {
    case 0:
        println("--有配置文件构建apk--")
        gradle.allComponents.depthFirst().each { component ->
            if (component.name() != "component" && component.name() != "dependency") return
            def componentName = component.@project.text()
            def aarVersion = component.@aarVersion.text()
            def include = component.@include.text()
            def aar = component.@aar.text()
            if (include == "false") {
                println "--$componentName:  不参与编译--"
                return
            }
            if (aar != "false") {
                println("--$componentName:    构建  使用aar   $gradle.aar_title:$componentName:$aarVersion")
            } else {
                incloudProject(component)
//                println("--构建$componentName:使用源码--:$componentName")
            }

        }
        break
    case 1:
        println("--无配置文件构建apk:使用源码--")
        gradle.allComponents.depthFirst().each { component ->
            incloudProject(component)
        }
        break
    case 2:
        println("--构建aar：使用源码--")
        gradle.allComponents.depthFirst().each { component ->
            incloudProject(component)
        }
        break
}

if (gradle.assembleType != 2) {
    if (gradle.enable_proguard) {
        println("--混淆:开启--")
    } else {
        println("--混淆:关闭--")
    }
}

//app和lib_config始终include
include ':app'

if (gradle.import_config) {
    include ':lib_config'
    project(':lib_config').projectDir = "../component_config/lib_config" as File
}

println("--base-setting.gradle------------------------------------------")

//定义全局替换规则
gradle.allprojects { subProject ->

    if (subProject == subProject.rootProject && gradle.assembleType == 2) {
        afterEvaluate {
            //处理构建aar时的联动依赖,相互关联的库:lib_core,lib_common
            //lib_common上传maven依赖lib_core上传maven,两个库同时上传
            gradle.allComponents.depthFirst().each { component ->

                def projectName = component.@project.text()

                if (component.name() == "dependency") {
                    def parentProjectName = component.parent().@project.text()

                    project(":${parentProjectName}").getTasksByName("publishAar", false)[0].dependsOn project(":${projectName}").getTasksByName("publishAar", false)
                } else {
                    println("ggggg------$projectName")
                    project(":${"app"}").getTasksByName("publishAarAll", false)[0].dependsOn project(":${projectName}").getTasksByName("publishAar", false)
                }
            }
        }
        return
    }

    //无配置文件构建apk或者构建aar时全部使用源码
    if (gradle.assembleType == 1 || gradle.assembleType == 2) {
        substituteProject(subProject, true)
    }

    //有配置文件构建apk时按照配置
    if (gradle.assembleType == 0) {
        //本地components_configs构建apk时剔除不参与编译的组件的aar依赖
        configurations {
            gradle.allComponents.depthFirst().each { component ->
                if (component.name() != "component" && component.name() != "dependency") return
                if ((component.name() == "component" || component.name() == "dependency")
                        && component.@project.text() != null && component.@include == "false") {
                    implementation { exclude group: "$gradle.aar_title", module: component.@project.text() }
                    implementation { exclude group: gradle.aar_title, module: component.@project.text() }
                }
            }
        }

        substituteProject(subProject, false)

    }
}

//是否是发布aar
def isPublishAar() {
    for (String task : gradle.startParameter.taskNames) {
        if (task.contains("publishAar") || task.contains("uploadArchives")) {
            return true
        }
    }
    return false
}

//把所有的包都导入到项目中,是否引用看各个module配置
//isForce:是否强制导入,构建aar时强制导入,否则只有主工程会导入
def incloudProject(def component) {

    def componentName = component.@project.text()

    if (componentName.startsWith("module_") && !(gradle.rootProjectname == rootProject.name)) {
        println("--$componentName:   非主项目不构建")
        return
    }
    println("--$componentName:  构建  使用源码")
    include ":${component.@project}"
    def includedesp = component.@project.text().split("_")[0]
    def includeName = component.@project.text().split("_")[1]
    project(":${includedesp}_$includeName").projectDir = "../component_$includeName/${includedesp}_$includeName" as File
}

/**
 * 引用替换 源码/aar
 * @param component
 * @param isForceSource 是否强制使用源码
 * @return
 */
def substituteProject(def subProject, def isForceSource) {

    subProject.configurations.all {
        resolutionStrategy {
            dependencySubstitution {
                gradle.allComponents.depthFirst().each { component ->

                    //校验
                    if (component.name() != "component" && component.name() != "dependency") return

                    def componentName = component.@project.text()

                    if (componentName.startsWith("module_") && !(gradle.rootProjectname == rootProject.name)) {
                        return
                    }

                    //构建aar，全部使用源码
                    if (isForceSource) {
                        substitute module("$gradle.aar_title:$componentName") using project(":$componentName")
                    } else {
                        def aarVersion = component.@aarVersion.text()
                        def include = component.@include.text()
                        def aar = component.@aar.text()
                        if (include == "false") return
                        if (aar != "false") {
                            //该逻辑为dependencySubstitution中的逻辑,可进入dependencySubstitution类中查看
                            substitute module("$gradle.aar_title:$componentName") using module("$gradle.aar_title:$componentName:$aarVersion")
                        } else {
                            substitute module("$gradle.aar_title:$componentName") using project(":$componentName")
                        }
                    }

                }
            }
        }
    }

}